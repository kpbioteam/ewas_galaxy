<tool id="minfi_read450k" name="Minfi Read 450k" version="2.1.0">
    <description>load .IDAT files</description>
  <macros>
        <import>macros.xml</import>
  </macros>
    <command detect_errors="exit_code"><![CDATA[

import os

# detect the current working directory
path = os.getcwd($files_red)

# read the entries
with os.scandir(path) as listOfEntries:  
    for entry in listOfEntries:
        # print all entries that are files
        if entry.is_file():
            print(entry.name)

      cat '$read_idat_script' &&
      Rscript '$read_idat_script'
      ]]></command>
      <configfiles>
      <configfile name="read_idat_script"><![CDATA[
        timeStart <- as.character(Sys.time())

# Load all required libraries
library(methods, quietly=TRUE, warn.conflicts=FALSE)
library(statmod, quietly=TRUE, warn.conflicts=FALSE)
library(splines, quietly=TRUE, warn.conflicts=FALSE)
library(edgeR, quietly=TRUE, warn.conflicts=FALSE)
library(limma, quietly=TRUE, warn.conflicts=FALSE)
library(scales, quietly=TRUE, warn.conflicts=FALSE)
library(getopt, quietly=TRUE, warn.conflicts=FALSE)
library(gplots, quietly=TRUE, warn.conflicts=FALSE)

################################################################################
### Function Declaration
################################################################################
# Function to sanitise contrast equations so there are no whitespaces
# surrounding the arithmetic operators, leading or trailing whitespace
sanitiseEquation <- function(equation) {
    equation <- gsub(" *[+] *", "+", equation)
    equation <- gsub(" *[-] *", "-", equation)
    equation <- gsub(" *[/] *", "/", equation)
    equation <- gsub(" *[*] *", "*", equation)
    equation <- gsub("^\\s+|\\s+$", "", equation)
    return(equation)
}

# Function to sanitise group information
sanitiseGroups <- function(string) {
    string <- gsub(" *[,] *", ",", string)
    string <- gsub("^\\s+|\\s+$", "", string)
    return(string)
}

# Function to change periods to whitespace in a string
unmake.names <- function(string) {
    string <- gsub(".", " ", string, fixed=TRUE)
    return(string)
}

# Generate output folder and paths
makeOut <- function(filename) {
    return(paste0(opt$outPath, "/", filename))
}

# Generating design information
pasteListName <- function(string) {
    return(paste0("factors$", string))
}

# Create cata function: default path set, default seperator empty and appending
# true by default (Ripped straight from the cat function with altered argument
# defaults)
cata <- function(..., file = opt$htmlPath, sep = "", fill = FALSE, labels = NULL,
               append = TRUE) {
    if (is.character(file))
        if (file == "")
            file <- stdout()
        else if (substring(file, 1L, 1L) == "|") {
            file <- pipe(substring(file, 2L), "w")
            on.exit(close(file))
        }
        else {
        file <- file(file, ifelse(append, "a", "w"))
      on.exit(close(file))
        }
    .Internal(cat(list(...), file, sep, fill, labels, append))
}

# Function to write code for html head and title
HtmlHead <- function(title) {
    cata("<head>\n")
    cata("<title>", title, "</title>\n")
    cata("</head>\n")
}

# Function to write code for html links
HtmlLink <- function(address, label=address) {
    cata("<a href=\"", address, "\" target=\"_blank\">", label, "</a><br />\n")
}

# Function to write code for html images
HtmlImage <- function(source, label=source, height=500, width=500) {
    cata("<img src=\"", source, "\" alt=\"", label, "\" height=\"", height)
    cata("\" width=\"", width, "\"/>\n")
}

# Function to write code for html list items
ListItem <- function(...) {
    cata("<li>", ..., "</li>\n")
}

TableItem <- function(...) {
    cata("<td>", ..., "</td>\n")
}

TableHeadItem <- function(...) {
    cata("<th>", ..., "</th>\n")
}

################################################################################
### Input Processing
################################################################################

# Collect arguments from command line
args <- commandArgs(trailingOnly=TRUE)

# Get options, using the spec as defined by the enclosed list.
# Read the options from the default: commandArgs(TRUE).
spec <- matrix(c(
    "htmlPath", "R", 1, "character",
    "outPath", "o", 1, "character",
    "filesPath", "j", 2, "character",
    "matrixPath", "m", 2, "character",
    "factFile", "f", 2, "character",
    "factInput", "i", 2, "character",
    "annoPath", "a", 2, "character",
    "contrastData", "C", 1, "character",
    "cpmReq", "c", 1, "double",
    "totReq", "y", 0, "logical",
    "cntReq", "z", 1, "integer",
    "sampleReq", "s", 1, "integer",
    "filtCounts", "F", 0, "logical",
    "normCounts", "x", 0, "logical",
    "rdaOpt", "r", 0, "logical",
    "lfcReq", "l", 1, "double",
    "pValReq", "p", 1, "double",
    "pAdjOpt", "d", 1, "character",
    "normOpt", "n", 1, "character",
    "robOpt", "b", 0, "logical",
    "trend", "t", 1, "double",
    "weightOpt", "w", 0, "logical",
    "topgenes", "G", 1, "integer",
    "treatOpt", "T", 0, "logical",
    "plots", "P", 1, "character",
    "libinfoOpt", "L", 0, "logical"),
    byrow=TRUE, ncol=4)
opt <- getopt(spec)


if (is.null(opt$matrixPath) & is.null(opt$filesPath)) {
    cat("A counts matrix (or a set of counts files) is required.\n")
    q(status=1)
}

if (is.null(opt$cpmReq)) {
    filtCPM <- FALSE
} else {
    filtCPM <- TRUE
}

if (is.null(opt$cntReq) || is.null(opt$sampleReq)) {
    filtSmpCount <- FALSE
} else {
    filtSmpCount <- TRUE
}

if (is.null(opt$totReq)) {
    filtTotCount <- FALSE
} else {
    filtTotCount <- TRUE
}

if (is.null(opt$rdaOpt)) {
    wantRda <- FALSE
} else {
    wantRda <- TRUE
}

if (is.null(opt$annoPath)) {
    haveAnno <- FALSE
} else {
    haveAnno <- TRUE
}

if (is.null(opt$filtCounts)) {
    wantFilt <- FALSE
} else {
    wantFilt <- TRUE
}

if (is.null(opt$normCounts)) {
    wantNorm <- FALSE
} else {
    wantNorm <- TRUE
}

if (is.null(opt$robOpt)) {
    wantRobust <- FALSE
} else {
    wantRobust <- TRUE
}

if (is.null(opt$weightOpt)) {
    wantWeight <- FALSE
} else {
    wantWeight <- TRUE
}

if (is.null(opt$trend)) {
    wantTrend <- FALSE
    deMethod <- "limma-voom"
} else {
    wantTrend <- TRUE
    deMethod <- "limma-trend"
    priorCount <- opt$trend
}

if (is.null(opt$treatOpt)) {
    wantTreat <- FALSE
} else {
    wantTreat <- TRUE
}

if (is.null(opt$libinfoOpt)) {
    wantLibinfo <- FALSE
} else {
    wantLibinfo <- TRUE
}


if (!is.null(opt$filesPath)) {
    # Process the separate count files (adapted from DESeq2 wrapper)
    library("rjson")
    library("minfi")

    parser <- newJSONParser()
    parser$addData(opt$filesPath)
    factorList <- parser$getObject()
    factors <- sapply(factorList, function(x) x[[1]])
    filenamesIn <- unname(unlist(factorList[[1]][[2]]))
    sampleTable <- data.frame(sample=basename(filenamesIn),
                            filename=filenamesIn,
                            row.names=filenamesIn,
                            stringsAsFactors=FALSE)
    for (factor in factorList) {
        factorName <- factor[[1]]
        sampleTable[[factorName]] <- character(nrow(sampleTable))
        lvls <- sapply(factor[[2]], function(x) names(x))
        for (i in seq_along(factor[[2]])) {
            files <- factor[[2]][[i]][[1]]
            sampleTable[files,factorName] <- lvls[i]
        }
        sampleTable[[factorName]] <- factor(sampleTable[[factorName]], levels=lvls)
    }
    rownames(sampleTable) <- sampleTable$sample
    rem <- c("sample","filename")
    factors <- sampleTable[, !(names(sampleTable) %in% rem), drop=FALSE]

    #read in count files and create single table
    countfiles <- lapply(sampleTable$filename, function(x){read.delim(x, row.names=1)})
    counts <- do.call("cbind", countfiles)

} else {
    # Process the single count matrix
    counts <- read.table(opt$matrixPath, header=TRUE, sep="\t", strip.white=TRUE, stringsAsFactors=FALSE, check.names=FALSE)
    row.names(counts) <- counts[, 1]
    counts <- counts[ , -1]
    countsRows <- nrow(counts)

    # Process factors
    if (is.null(opt$factInput)) {
        factorData <- read.table(opt$factFile, header=TRUE, sep="\t", strip.white=TRUE)
        if(!setequal(factorData[, 1], colnames(counts)))
            stop("Sample IDs in counts and factors files don't match")
        # order samples as in counts matrix
        factorData <- factorData[match(colnames(counts), factorData[, 1]), ]
        factors <- factorData[, -1, drop=FALSE]
    }  else {
        factors <- unlist(strsplit(opt$factInput, "|", fixed=TRUE))
        factorData <- list()
        for (fact in factors) {
            newFact <- unlist(strsplit(fact, split="::"))
            factorData <- rbind(factorData, newFact)
        } # Factors have the form: FACT_NAME::LEVEL,LEVEL,LEVEL,LEVEL,... The first factor is the Primary Factor.

        # Set the row names to be the name of the factor and delete first row
        row.names(factorData) <- factorData[, 1]
        factorData <- factorData[, -1]
        factorData <- sapply(factorData, sanitiseGroups)
        factorData <- sapply(factorData, strsplit, split=",")
        # Transform factor data into data frame of R factor objects
        factors <- data.frame(factorData)
    }
}
# check there are the same number of samples in counts and factors
if(nrow(factors) != ncol(counts)) {
    stop("There are a different number of samples in the counts files and factors")
}

        out <- read.metharray(entry.name)

        save(out, file = '$RGChannelSet')
        ]]> </configfile>
        </configfiles>
        <inputs>
            <!-- Counts and Factors -->
        <conditional name="input">
            <param name="format" type="select" label="Count Files or Matrix?"
                help="You can choose to input either separate count files (one per sample) or a single count matrix">
                <option value="files">Separate Count Files</option>
                <option value="matrix">Single Count Matrix</option>
            </param>

            <when value="files">
                <repeat name="rep_factor" title="Factor" min="1">
                    <param name="factorName" type="text" label="Name" help="Name of experiment factor of interest (e.g. Genotype). One factor must be entered and there must be two or more groups per factor. Optional additional factors (e.g. Batch) can be entered using the Insert Factor button below, see Help section for more information. NOTE: Please only use letters, numbers or underscores.">
                    <sanitizer>
                        <valid initial="string.letters,string.digits"><add value="_" /></valid>
                    </sanitizer>
                    </param>
                    <repeat name="rep_group" title="Group" min="2" default="2">
                        <param name="groupName" type="text" label="Name"
                        help="Name of group that the counts files belong to (e.g. WT or Mut). NOTE: Please only use letters, numbers or underscores (case sensitive).">
                        <sanitizer>
                            <valid initial="string.letters,string.digits"><add value="_" /></valid>
                        </sanitizer>
                        </param>
                        <param name="idatsFile" type="data" format="tabular" multiple="true" label="Counts files"/>
                    </repeat>
                </repeat>
            </when>

            <when value="matrix">
                <param name="counts" type="data" format="tabular" label="Count Matrix"/>

                <conditional name="fact">
                    <param name="ffile" type="select" label="Input factor information from file?"
                        help="You can choose to input the factor and group information for the samples from a file or manually enter below. NOTE: Please only use letters, numbers or underscores (case sensitive), the group names MUST not contain hyphens.">
                        <option value="no">No</option>
                        <option value="yes">Yes</option>
                    </param>
                    <when value="yes">
                        <param name="finfo" type="data" format="tabular" label="Factor File"/>
                    </when>
                    <when value="no" >
                        <repeat name="rep_factor" title="Factor" min="1">
                            <param name="factorName" type="text" label="Factor Name"
                                help="Name of experiment factor of interest (e.g. Genotype). One factor must be entered and there must be two or more groups per factor. Additional factors (e.g. Batch) can be entered using the Insert Factor button below, see Help section below. NOTE: Please only use letters, numbers or underscores.">
                                <validator type="empty_field" />
                                <validator type="regex" message="Please only use letters, numbers or underscores">^[\w]+$</validator>
                            </param>
                            <param name="groupNames" type="text" label="Groups"
                                help="Enter the group names for the samples separated with commas e.g. WT,WT,WT,Mut,Mut,Mut. The order of the names must match the order of the samples in the columns of the count matrix. NOTE: Please only use letters, numbers or underscores (case sensitive), the group names MUST not contain hyphens.">
                                <validator type="empty_field" />
                                <validator type="regex" message="Please only use letters, numbers or underscores, and separate levels by commas">^[\w,]+$</validator>
                            </param>
                        </repeat>
                    </when>
                </conditional>
            </when>
        </conditional>
            </inputs>
            <outputs>
            <data name="RGChannelSet" format="rdata" label="RGChannelSet"/>
              </outputs>
      <tests>   
            <test>
            <param name="format" value="files" />
            <repeat name="rep_factor">
                <param name="factorName" value="Sensitivity"/>
                <repeat name="rep_group">
                    <param name="groupName" value="sensitive"/>
                    <param name="idatsFile" value="GSM1588704_8795207135_R01C02_Red.idat, GSM1588704_8795207135_R01C02_Grn.idat
                    GSM1588705_8795207119_R05C02_Red.idat, GSM1588705_8795207119_R05C02_Grn.idat"/>
                </repeat>
                <repeat name="rep_group">
                    <param name="groupName" value="resistant"/>
                    <param name="idatsFile" value="GSM1588706_8795207135_R02C02_Red.idat, GSM1588706_8795207135_R02C02_Grn.idat
                    GSM1588707_8795207119_R06C02_Red.idat, GSM1588707_8795207119_R06C02_Grn.idat"/>
                </repeat>
            </repeat>
            <repeat name="rep_factor">
                <param name="factorName" value="Treatment"/>
                <repeat name="rep_group">
                    <param name="groupName" value="MAPKi"/>
                    <param name="idatsFile" value="GSM1588704_8795207135_R01C02_Red.idat, GSM1588704_8795207135_R01C02_Grn.idat
                    GSM1588705_8795207119_R05C02_Red.idat, GSM1588705_8795207119_R05C02_Grn.idat"/>
                </repeat>
                <repeat name="rep_group">
                    <param name="groupName" value="BRAFi"/>
                    <param name="idatsFile" value="GSM1588706_8795207135_R02C02_Red.idat, GSM1588706_8795207135_R02C02_Grn.idat
                    GSM1588707_8795207119_R06C02_Red.idat, GSM1588707_8795207119_R06C02_Grn.idat"/>
                </repeat>
            <output name="RGChannelSet" file="RGChannelSet.rdata"/>
                </repeat>
                </test>
             </tests>

    <help><![CDATA[
.. class:: infomark

**What it does**

The tool load the binary 450K array “IDAT” raw files generated by the Illumina Scanner. In addition to the methylated and an unmethylated intensity values for each 450,000 CpG positions, IDAT file contains some extra info such as control probes.

-----

**Input Data:**
The counts data can either be input as separate counts files (one sample per file) or a single count matrix (one sample per column). The rows correspond to genes, and columns correspond to the counts for the samples. Values must be tab separated, with the first row containing the sample/column labels and the first column containing the row/gene labels. The sample labels must start with a letter. Gene identifiers can be of any type but must be unique and not repeated within a counts file.

Example - **Separate Idats Files**:

GSM1588707_8795207119_R06C02_Red.idat,GSM1588706_8795207135_R02C02_Red.idat,GSM1588705_8795207119_R05C02_Red.idat,GSM1588704_8795207135_R01C02_Red.idat

Example - **Single Idat Matrix**:

    ========================= ====================== ======================== 
          **File Name**          **Sensitivity**          **Treatment** 
    ------------------------- ---------------------- ------------------------ 

    ========================= ====================== ======================== 

    ]]></help>
    <citations>
         <citation type="doi">10.18129/B9.bioc.illuminaio</citation>
    </citations>
</tool>
